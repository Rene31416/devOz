import { inject, injectable } from "inversify";
import { DynamoDBClient } from "@aws-sdk/client-dynamodb";
import { v4 as uuidv4 } from "uuid";
import {
  DeleteCommand,
  DynamoDBDocumentClient,
  QueryCommand,
  PutCommand,
  ScanCommand,
  UpdateCommand,
} from "@aws-sdk/lib-dynamodb";
import { Logger } from "@aws-lambda-powertools/logger";
import {
  GenericError,
  IApiResponse,
  ResponseMessage,
  StatusCode,
} from "../interfaces/projectInterfaces";
/**
 * add creation date for sort
 * use uuid for autogenerated Id, validate for existance for name
 */
@injectable()
export class Project {
  private readonly tableName = process.env.TABLE_PROJECTS_NAME || "";
  private readonly client = new DynamoDBClient({ region: "ca-central-1" });
  private docClient: DynamoDBDocumentClient;

  constructor(
    @inject(Logger)
    private logger: Logger
  ) {
    this.docClient = DynamoDBDocumentClient.from(this.client);
  }
  public async getAllList(): Promise<IApiResponse> {
    try {
      const response = await this.docClient.send(
        new ScanCommand({
          TableName: this.tableName,
        })
      );
      return {
        statusCode: 200,
        message: ResponseMessage.GeneralSuccess,
        data: response.Items,
      };
    } catch (error: any) {
      this.logger.error("Unexpected Error", { error });
      return GenericError;
    }
  }

  public async getProject(id: string): Promise<IApiResponse> {
    try {
      const itemParams = {
        TableName: this.tableName,
        IndexName: "tableGsi",
        KeyConditionExpression: "id = :pk",
        ExpressionAttributeValues: {
          ":pk": id,
        },
      };

      const response = await this.docClient.send(new QueryCommand(itemParams));
      if (response.Items?.length === 0) {
        return {
          statusCode: StatusCode.PartialSucess,
          message: ResponseMessage.NoItemsFound,
          data: [],
        };
      }
      return {
        statusCode: StatusCode.Sucess,
        message: ResponseMessage.GeneralSuccess,
        data: response.Items || [],
      };
    } catch (error: any) {
      this.logger.error("Unexpected Error", { error });
      return GenericError;
    }
  }

  public async postProject(body: Record<any, any>): Promise<IApiResponse> {
    try {
      const params = {
        TableName: this.tableName,
        Item: {
          ...body,
          id: uuidv4(),
        },
        ConditionExpression: "attribute_not_exists(#name)",
        ExpressionAttributeNames: {
          "#name": "name",
        },
      };
      await this.docClient.send(new PutCommand(params));

      return {
        statusCode: 200,
        message: ResponseMessage.GeneralSuccess,
      };
    } catch (error: any) {
      if (error.name === "ConditionalCheckFailedException")
        return { statusCode: 201, message: "Item already exists []" };
      this.logger.error("Unexpected Error", { error });
      return GenericError;
    }
  }

  public async putProject(body: Record<any, any>): Promise<IApiResponse> {
    try {
      const params = {
        TableName: this.tableName,
        Key: {
          pk: "name", // Your partition key
        },
        UpdateExpression: "SET #name = :name, #description = :description",
        ExpressionAttributeNames: {
          "#name": "name",
          "#description": "description",
        },
        ExpressionAttributeValues: {
          ":name": body.name,
          ":description": body.description,
        }, // Optional: returns only updated fields
      };
      this.docClient.send(new UpdateCommand(params));
      return {
        statusCode: 200,
        message: ResponseMessage.GeneralSuccess,
      };
    } catch (error: any) {
      this.logger.error("Unexpected Error", { error });
      return GenericError;
    }
  }

  public async deleteProject(id: string): Promise<IApiResponse> {
    try {
      //query for ID gsi to find pk (#name)
      const deleteQueryParams = {
        TableName: this.tableName,
        IndexName: "tableGsi",
        KeyConditionExpression: "id = :pk",
        ExpressionAttributeValues: {
          ":pk": id,
        },
      };
      const queryResponse = await this.docClient.send(
        new QueryCommand(deleteQueryParams)
      );
      //delete all record under pk (should be unique)
      for (const item of queryResponse.Items ?? []) {
        console.log(item)
        const pk = item.name; 
        const params = {
          TableName: this.tableName,
          Key: {
            name: pk,
          },
        };
        await this.docClient.send(new DeleteCommand(params));
      }

      return {
        statusCode: 200,
        message: ResponseMessage.GeneralSuccess,
      };
    } catch (error: any) {
      this.logger.error("Unexpected Error", { error });
      return GenericError;
    }
  }
}
