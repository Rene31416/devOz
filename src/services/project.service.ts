import { DynamoDBClient } from "@aws-sdk/client-dynamodb";
import { inject, injectable } from "inversify";
import { v4 as uuidv4 } from "uuid";
import {
  DeleteCommand,
  DynamoDBDocumentClient,
  QueryCommand,
  PutCommand,
  ScanCommand,
  UpdateCommand,
  GetCommand,
} from "@aws-sdk/lib-dynamodb";
import { Logger } from "@aws-lambda-powertools/logger";
import {
  GenericError,
  IApiResponse,
  ResponseMessage,
  StatusCode,
} from "../interfaces/projectInterfaces";
/**
 * add creation date for sort
 * use uuid for autogenerated Id, validate for existance for name
 */
@injectable()
export class Project {
  private readonly tableName = process.env.TABLE_PROJECTS_NAME || "";
  private readonly client = new DynamoDBClient({ region: "ca-central-1" });
  private docClient: DynamoDBDocumentClient;

  constructor(
    @inject(Logger)
    private logger: Logger
  ) {
    this.docClient = DynamoDBDocumentClient.from(this.client);
  }
  public async getAllList(): Promise<IApiResponse> {
    try {
      const response = await this.docClient.send(
        new ScanCommand({
          TableName: this.tableName,
        })
      );
      const Items = [];
      for (const project of response.Items ?? []) {
        Items.push({
          name: project.name,
          id: project.id,
        });
      }

      return {
        statusCode: 200,
        message: ResponseMessage.GeneralSuccess,
        data: Items,
      };
    } catch (error: any) {
      this.logger.error("Unexpected Error", { error });
      return GenericError;
    }
  }

  public async getProject(id: string): Promise<IApiResponse> {
    try {
      const itemParams = {
        TableName: this.tableName,
        Key: {
          id,
        },
        KeyConditionExpression: "id = :id",
        ExpressionAttributeValues: {
          ":id": id,
        },
      };

      const response = await this.docClient.send(new QueryCommand(itemParams));

      if (!response.Items || response.Items.length === 0) {
        return {
          statusCode: StatusCode.PartialSucess,
          message: ResponseMessage.NoItemsFound,
          data: [],
        };
      }
      return {
        statusCode: StatusCode.Sucess,
        message: ResponseMessage.GeneralSuccess,
        data: response.Items[0] || [],
      };
    } catch (error: any) {
      this.logger.error("Unexpected Error", { error });
      return GenericError;
    }
  }

  public async postProject(body: Record<any, any>): Promise<IApiResponse> {
    try {
      const id = uuidv4 ()
      const params = {
        TableName: this.tableName,
        Item: {
          ...body,
          id
        },
      };
      console.log(params)
      await this.docClient.send(new PutCommand(params));

      return {
        statusCode: 200,
        message: ResponseMessage.GeneralSuccess,
      };
    } catch (error: any) {
      if (error.name === "ConditionalCheckFailedException")
        return { statusCode: 201, message: "Item already exists []" };
      this.logger.error("Unexpected Error", { error });
      return GenericError;
    }
  }

  public async putProject(body: Record<any, any>): Promise<IApiResponse> {
    try {
      const params = {
        TableName: this.tableName,
        Key: {
          id: body.id// Your partition key
        },
        UpdateExpression: "SET #name = :name, #description = :description",
        ExpressionAttributeNames: {
          "#name": "name",
          "#description": "description",
        },
        ExpressionAttributeValues: {
          ":name": body.name,
          ":description": body.description,
        }, // Optional: returns only updated fields
      };
      console.log(params);
      await this.docClient.send(new UpdateCommand(params));
      return {
        statusCode: 200,
        message: ResponseMessage.GeneralSuccess,
      };
    } catch (error: any) {
      this.logger.error("Unexpected Error", { error });
      return GenericError;
    }
  }

  public async deleteProject(id: string): Promise<IApiResponse> {
    try {
      const params = {
        TableName: this.tableName,
        Key: {
          id
        },
      };
      console.log(params);
      await this.docClient.send(new DeleteCommand(params));

      return {
        statusCode: 200,
        message: ResponseMessage.GeneralSuccess,
      };
    } catch (error: any) {
      this.logger.error("Unexpected Error", { error });
      return GenericError;
    }
  }
}
